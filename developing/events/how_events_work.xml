<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "http://docs.oasis-open.org/dita/v1.1/OS/dtd/concept.dtd">
<concept id="how_events_work">
	<title>How Events Work</title>
	<shortdesc id="shortdesc_D8F95F7C1D2A4C05B1D61A9184DA3523">Members in your <keyword
			keyref="product_name"/> distributed system receive cache updates from other members
		through cache events. The other members can be peers to the member, clients or servers or
		other distributed systems. </shortdesc>
	<conbody>
		<section id="section_6C75098DDBB84944ADE57F2088330D5A">
			<title>Events Features</title>
			<p>These are the primary features of <keyword keyref="product_name"/> events: </p>
				<ul
					id="ul_8C6B9C8F89E24F81AF7097290EB43D8F">
					<li id="li_ECF128F5AFCF4AFAB0D1F138F3BA3835">Content-based events </li>
					<li id="li_0E28268A62294F079F663C7A42F67086">Asynchronous event notifications
						with conflation </li>
					<li id="li_D533A31AF90E4749B30D58361FDB9AB8">Synchronous event notifications for
						low latency </li>
					<li id="li_FFC7D82011A546E9BA665D3C1EA6D255">High availability through redundant
						messaging queues </li>
					<li id="li_E654AB80D19C47BC89C97645DA473D72">Event ordering and once and
						only-once delivery </li>
					<li id="li_B01269FC078C4E28B349213A1FE32FA1">Distributed event notifications </li>
					<li id="li_517DD01F196A43BF80D3F989EB702F83">Durable subscriptions </li>
					<li id="li_ACED060CB708431DB021323F918F3CF7">Continuous querying </li>
				</ul>
		</section>
		<section id="section_F5F0E506652940DFBA0D6B7AAA72E3EF">
			<title>Types of Events</title>
			<p>There are two categories of events and event handlers.</p>
				<ul
					id="ul_D51552C793B24E7D9E6883C483A9B483">
					<li id="li_220A4D1E1E174DFBA836E32C78DB58E4">Cache events in the caching API are used by
						applications with a cache. Cache events provide detail-level notification
						for changes to your data. Continuous query events are in this category. </li>
					<li>Administrative events in the administration API are used by administrative
						applications without caches.</li>
				</ul>
			<p>Both kinds of events can be generated by a single member operation. </p>
				<note>
					<p>You can handle one of these categories of events in a single system member.
					You cannot handle both cache and administrative events in a single member.
					</p>
				</note>
			Because <keyword keyref="product_name"/> maintains the order of
				administrative events and the order of cache events separately, using cache events
				and administrative events in a single process can cause unexpected results. 
		</section>
		<section id="section_4BCDB22AB927478EBF1035B0DE230DD3">
			<title>Event Cycle</title>
			<p>The following steps describe the event cycle: </p>
				<ol
					id="ol_E19EBD15F50F4DDAB5F13F51F4639E70">
					<li id="li_3BF425D78D4C418DA9B54DCF9246F429">An operation begins, such as data
						put or a cache close. </li>
					<li id="li_D3CBD6F14EC44673B3062A6ED4BB9E50">The operation execution generates
						these objects: <ul id="ul_3DE24E3A0CA2437AAFADAD717255887F">
							<li id="li_81915B54683F4AA6B40845DFFB607CA5">An object of type
									<codeph>Operation</codeph> that describes the method that
								triggered the event. </li>
							<li id="li_399E97DD214B4FD1B890DA39F1B09067">An event object that
								describes the event, such as the member and region where the
								operation originated. </li>
						</ul>
					</li>
					<li id="li_16C37DE6BCF64B1E8A7FEDCA05793F63">The event handlers that can handle
						the event are called and passed the event objects. Different event types
						require different handler types in different locations. If there is no
						matching event handler, that does not change the effect of the operation,
						which happens as usual. </li>
					<li id="li_CA018428C8A74DB49493BBF5C28BAD6A">When the handler receives the
						event, it triggers the handlerâ€™s callback method for this event. The
						callback method can hand off the event object as input to another method.
						Depending on the type of event handler, the callbacks can be triggered
						before or after the operation. The timing depends on the event handler, not
						on the event itself.
							<note>
								<p>For transactions, after-operation listeners receive the events
								after the transaction has committed. 
								</p>
							</note>
					</li>
					<li id="li_4E4D551C0FFB492DBB2BE723866251E6">If the operation is distributed, so
						that it causes follow-on operations in other members, those operations
						generate their own events, which can be handled by their listeners in the
						same way. </li>
				</ol>
		</section>
		<section id="section_E48ECC8A1B39411AA23D17BA0C05517E">
			<title>Event Objects</title>
			<p>Event objects come in several types, depending on the operation. Some operations
				generate multiple objects of different types. All event objects contain data
				describing the event, and each event type carries slightly different kinds of data
				appropriate to its matching operation. An event object is stable. For example, its
				content does not change if you pass it off to a method on another thread. </p>
			<p>For cache events, the event object describes the operation performed in the local
				cache. If the event originated remotely, it describes the local application of the
				remote entry operation, not the remote operation itself. The only exception is when
				the local region has an empty data policy; then the event carries the information
				for the remote (originating) cache operation. </p>
		</section>
		<section id="section_2EA59E9F7203433A8AD248C499D61BF4">
			<title>Event Distribution</title>
			<p>After a member processes an event in its local cache, it distributes it to remote caches
				according to the member's configuration and the configurations of the remote caches.
				For example, if a client updates its cache, the update is forwarded to the client's
				server. The server distributes the update to its peers and forwards it to any other
				clients according to their interest in the data entry. If the server system is part
				of a multi-site deployment and the data region is configured to use a gateway
				sender, then the gateway sender also forwards the update to a remote site, where the
				update is further distributed and propagated. </p>
		</section>
		<section id="section_C18D3CA923FB427AA01DD811589D63C0">
			<title>Event Handlers and Region Data Storage</title>
			<p>You can configure a region for no local data storage and still send and receive
				events for the region. Conversely, if you store data in the region, the cache is
				updated with data from the event regardless of whether you have any event handlers
				installed. </p>
		</section>
		<section id="section_22EB4B9E6C4445F898DB64A769780460">
			<title>Multiple Listeners</title>
			<p>When multiple listeners are installed, as can be done with cache listeners, the
				listeners are invoked sequentially in the order they were added to the region or
				cache. Listeners are executed one at a time. So, unless you program a listener to
				pass off processing to another thread, you can use one listener's work in later
				listeners. </p>
		</section>
		<section id="section_C4758D7E2CA2498A87315DE903A07AE4">
			<title>Event Ordering</title>
			<p>During a cache operation, event handlers are called at various stages of the
				operation. Some event handlers are called before a region update and some are called
				after the region update operation. Depending on the type of event handler being
				called, the event handler can receive the events in-order or out-of-order in which
				they are applied on Region. </p>
				<ul id="ul_A1795967A0C64848B146062FC613AA4D">
					<li id="li_127F4CA9CB874698913AF5194A885082"><codeph>CacheWriter</codeph> and
							<codeph>AsyncEventListener</codeph> always receive events in the order
						in which they are applied on region. </li>
					<li id="li_1A80FCA231A6445C907BF54A9D5970C1"><codeph>CacheListener</codeph> and
							<codeph>CqListener</codeph> can receive events in a different order than
						the order in which they were applied on the region. </li>
				</ul>
				<note>
					<p>An <codeph>EntryEvent</codeph> contains both the old value and the new value
					of the entry, which helps to indicate the value that was replaced by the cache
					operation on a particular key.
					</p>
				</note>
		</section>
	</conbody>
</concept>
