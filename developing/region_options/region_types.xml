<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "http://docs.oasis-open.org/dita/v1.1/OS/dtd/concept.dtd">
<concept id="region_types">
	<title>Region Types</title>
	<shortdesc id="shortdesc_559DCD41E31446DB9DF5ECFD15AC867B">Region types define the data storage and
		distribution behavior within a distributed system.</shortdesc>
	<conbody>
		<section id="section_E3435ED1D0D142538B99FA69A9E449EF">
			<p><keyword keyref="product_name"/> has both distributed and non-distributed regions, such that
				you can define regions whose data is spread across the distributed system, as well
				as regions whose data is entirely contained in a single member. </p>
			<p>The appropriate type of region depends on the application. The regions of a client/server
				system have more restrictions, to provide effective communication between the two
				tiers. Guidelines for region type: <ul id="ul_328ea15b-8d11-43f9-87ba-e1753f26c239">
					<li id="li_5248B58F175548E1A5B025EE0BEAD1A8">Server regions are created inside a
							<codeph>Cache</codeph> by servers and are accessed by clients that
						connect to the servers from outside the server's distributed system. Server
						regions must have region type partitioned or replicated. Server region
						configuration uses the <codeph>RegionShortcut</codeph> enum settings.</li>
					<li id="li_CE0BDAC63C4443A5B49D61B18EADB851">Client regions are created inside a
							<codeph>ClientCache</codeph> by clients and are configured to distribute
						data and events between the client and the server tier. Client regions must
						have region type local. Client region configuration uses the
							<codeph>ClientRegionShortcut</codeph> enum settings. </li>
					<li id="li_D663937A9D0042EE8F10AC182331AAF0">Peer regions are created inside a
							<codeph>Cache</codeph>. Peer regions may be server regions, or they may
						be regions that are not accessed by clients. Peer regions can have any
						region type. Peer region configuration uses the
							<codeph>RegionShortcut</codeph> enum settings. </li>
				</ul>
			</p>
		</section>
		<section id="section_C92C7DBD8EF44F1789FCB36281D3F8BF">
			<title>Partitioned Regions</title>
			<p>Partitioned regions map entries into buckets, and each member stores a subset of the buckets.
				Which bucket an entry is assigned to does not affect the logical view. All members
				see the same logical data set. Configuration allows the specification of redundant
				copies of buckets, leading to higher availablility in case of member failure.</p>
			<p>Use partitioning for: <ul id="ul_EEF600FD984346B285B8E82F5E47BD29">
					<li id="li_FF7B924C7DB1458695E824AF02B92997"><b>Large data sets</b>. Since each member hosts a
						subset of the region entries, no member hosts all of the regionâ€™s data.
							<keyword keyref="product_name"/> provides dynamic redundancy recovery.
							<keyword keyref="product_name"/> can rebalance partitioned regions,
						facilitating system throughput and horizontal scaling, as new members are
						added. </li>
					<li id="li_6528B3B018844D5881A1C536267A9E9B"><b>High availability</b>. Partitioned regions
						allow specification of the number of redundant copies of data entries. If a
						member fails, the entries will be available without interruption from the a
						remaining member's copy. Partitioned regions can also be persisted to disk
						for additional high availability. </li>
					<li id="li_394A5D02F8094790A3BE53EAA13CF04C"><b>Scalability</b>. Partitioned regions can scale
						to hold large amounts of data, because the data is divided among the members
						hosting the region. Increase data capacity dynamically by adding new
						members. Partitioned regions also allow increased processing capacity,
						because the region entries are spread across the members hosting the region,
						such that reads and writes to those entries are also spread out across those
						members. </li>
					<li id="li_75C74CD33F2946D094E35AF0B95D9666"><b>Good write performance</b>. You
						can configure the number of copies of your data. The amount of data
						transmitted per write does not increase with the number of members. By
						contrast, with replicated regions, each write must be sent to every member
						that has the region replicated, so the amount of data transmitted per write
						increases with the number of members. </li>
				</ul>
			</p>
			<p>In partitioned regions, you can colocate keys within buckets and across multiple
				partitioned regions. You can also control which members store which data buckets.
			</p>
			<p>Partitioned regions generally require more JDBC connections than other region types,
				because each member that hosts data must have a connection. </p>
		</section>
		<section id="section_iwt_dnj_bm">
			<title>Replicated Regions</title>
			<p>Each member hosts the entire region, meaning all the region's entries. Replicated regions
				provide the highest performance in terms of throughput and latency. They are most
				appropriate for small, read-heavy data sets.</p>
			<p>Use replicated regions for: <ul id="ul_307615353A48423E85CBD2AFF4F05A5C">
					<li id="li_D8B8E58C75EA46F7B754F508F648D05A"><b>Small to medium quantities of data that fit
							well within a single member</b>. Examples of small data sets are
						currency rate information and mortgage rates. </li>
					<li id="li_C72620EFE1F443F8AAFC28009A6DE29C"><b>High performance data access</b>. Replication
						means that reads remain local. Access is from the heap for application
						threads, providing the lowest possible latency. Queries benefit in the same
						manner.</li>
					<li id="li_94D285258ADD4291806DAEB3CEED1E47"><b>Asynchronous distribution</b>. The default
						distribution of data from one member to another does not require locking or
						acknowledgement, so replicated regions provide the fastest distribution
						speeds. </li>
				</ul>
			</p>
			<p>It is possible to set up a member within a replicated region such that the member
				does not store the entire region, and thus, is not a replica. Instead, the member
				interacts with the other region's members through the distribution of entries. The
				member is then acting as if it were a client within a client/server system, while
				being a member of a peer-to-peer system.</p>
		</section>
		<section id="section_A8150BDBC74E4019B1942481877A4370">
			<title>Local Regions</title>
			<p>A local region is only visible to the member that defines the region. A local region has no
				peer-to-peer distribution activity. </p>
			<p>Use local regions for: <ul id="ul_9F2EE05E49214FEABD83D5806C681C27">
					<li id="li_7FC21C4DD7AF4866AAA2235698158060"><b>Client regions</b>. Distribution
						is only between the client and server tier. </li>
					<li id="li_CD4AD2D0597D475CB215BDB0ADD779AC"><b>Private data sets</b>. The local region is not
						visible to peer members, so the data is private to the defining member. </li>
				</ul>
			</p>
			<p>When created using <codeph>ClientRegionShortcut</codeph> settings, client regions are
				automatically defined as local, since all client distribution activities go to and
				come from the server tier. </p>
		</section>
	</conbody>
</concept>
