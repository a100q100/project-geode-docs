<?xml version="1.0"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept
  id="concept_F38FDBC327204B4EB1E0BC74B4C95409">
  <title>Using C++ Enum Type with PDX Serialization</title>
  <shortdesc>Because there is no "object" base type in C++, enums cannot be
    directly passed as a parameter to the <codeph>writeObject</codeph> and
      <codeph>readObject</codeph> API. </shortdesc>
  <conbody>
    <p>To use the C++ enum type with PDX serialization, you will have to wrap
      the <codeph>enum</codeph> in the <codeph>CacheableEnum</codeph> class type
      by specifying classname, enumname and ordinal.</p>
      <codeblock>enum enumQuerytest { id1, id2, id3 };
 class TESTOBJECT_EXPORT PdxEnumTestClass :public PdxSerializable
  {
  private:
    int m_id;
    CacheableEnumPtr m_enumid;

  public:
    int getID(){
      return m_id;
    }

    CacheableEnumPtr getEnumID() {
      return m_enumid;
    }

    PdxEnumTestClass(int id)
    {
      m_id = id;
      switch (m_id) {
        case 0:
          m_enumid = CacheableEnum::create("enumQuerytest", "id1", id1);
          break;
        case 1:
          m_enumid = CacheableEnum::create("enumQuerytest", "id2", id2);
          break;
        case 2:
          m_enumid = CacheableEnum::create("enumQuerytest", "id3", id3);
          break;
        default:
          m_enumid = CacheableEnum::create("enumQuerytest", "id1", id1);
          break;
      }
    }

    PdxEnumTestClass() { }

    void toData(PdxWriterPtr pw) {
      pw-&gt;writeInt("m_id", m_id);
      pw-&gt;writeObject("m_enumid", m_enumid);
    }

    void fromData(PdxReaderPtr pr) {
      m_id = pr-&gt;readInt("m_id");
      m_enumid = pr-&gt;readObject("m_enumid");
    }

    CacheableStringPtr toString() const {
      return CacheableString::create("PdxEnumTestClass");
    }

    char* GetClassName() const {
      return "com.example.PdxEnumTestClass";
    }

    static PdxSerializable* createDeserializable() {
      return new PdxEnumTestClass();
    }
  };</codeblock>
    <section
      id="section_3491F76DB8C0464D89418B89372BBAEA">
      <title>How Put and Queries Work on Enum</title>
      <p>The following code sample demonstrates how put and query operations
        work when using the C++ enum Type with PDX serialization:</p>
        <codeblock>
//Creating objects of type PdxEnumTestClass
PdxEnumTestClassPtr pdxobj1(new PdxEnumTestClass(0));
PdxEnumTestClassPtr pdxobj2(new PdxEnumTestClass(1));
PdxEnumTestClassPtr pdxobj3(new PdxEnumTestClass(2));

RegionPtr rptr = getHelper()-&gt;getRegion( "DistRegionAck" );

//PUT Operations
rptr-&gt;put( CacheableInt32::create(0), pdxobj1 );
LOG( "pdxPut 1 completed " );

rptr-&gt;put( CacheableInt32::create(1), pdxobj2 );
LOG( "pdxPut 2 completed " );

rptr-&gt;put( CacheableInt32::create(2), pdxobj3 );
LOG( "pdxPut 3 completed " );


//Query
try {
    Serializable::registerPdxType(PdxEnumTestClass::createDeserializable);
    LOG("PdxEnumTestClass Registered Successfully....");
} catch (gemfire::IllegalStateException&amp;/* ex*/) {
    LOG("PdxEnumTestClass IllegalStateException");
}

RegionPtr rptr = getHelper()-&gt;getRegion( "DistRegionAck" );
SelectResultsPtr results = rptr-&gt;query("m_enumid.name = 'id2'");  
ASSERT(results-&gt;size()== 1 , "query result should have one item");
ResultSetPtr rsptr = dynCast&lt;ResultSetPtr&gt;(results);
SelectResultsIterator iter = rsptr-&gt;getIterator();  
while (iter.moveNext()) {
    PdxEnumTestClassPtr re = dynCast&lt;PdxEnumTestClassPtr&gt;(iter.current());
    ASSERT(re-&gt;getID()== 1 , "query should have returned id 1");
}    </codeblock>
    </section>
  </conbody>
</concept>
