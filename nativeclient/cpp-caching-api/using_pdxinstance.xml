<?xml version="1.0"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept
	id="concept_713A038D33774A0BB8D7632715A995B5">
	<title>Programming Your Application to Use PdxInstances</title>
	<shortdesc>A <codeph>PdxInstance</codeph> is a lightweight wrapper around the raw bytes of the PDX
		serialized objects kept in the cache. It provides applications with run-time access to files
		of a PDX serialized object. <keyword keyref="product_name"/> provides the implementation of
		the <codeph>PdxInstance</codeph> class. </shortdesc>
	<conbody>
		<p>You can configure your cache to return a <codeph>PdxInstance</codeph>
			when a PDX serialized object is deserialized instead of
			deserializing the object to a domain class. Preventing
			deserialization saves both time and memory and does not require you
			deserialize the object to the domain class. </p>
		<p>This configuration can be done in cache.xml by setting the attribute
				<codeph>read-serialized</codeph> to <codeph>true</codeph> on the
			&lt;pdx&gt;element. Or it can be done programmatically using the
				<codeph>CacheFactory::setPdxReadSerialized(bool)</codeph>
			method. </p>
		<p>After this preference is configured, any time a PDX object is
			deserialized, it is deserialized into a
			<codeph>PdxInstance</codeph>. </p>
		<p>The following is a code sample of using the setField API of
			PdxInstance to modify fields:</p>
			<codeblock>
RegionPtr rptr = getHelper()-&gt;getRegion( regionNames[0] );
CacheableKeyPtr keyport = CacheableKey::create("pdxput");
CacheableKeyPtr keyport1 = CacheableKey::create("pdxput2");

PdxInstancePtr pIPtr = dynCast&lt;PdxInstancePtr&gt;(rptr-&gt;get(keyport));
LOG( "modifyPdxInstance get complete." );

WritablePdxInstancePtr wpiPtr( pIPtr-&gt;createWriter());

ASSERT(pIPtr != NULLPTR, "pIPtr != NULLPTR expected");   
int val = 0;
int newVal = 0;
ASSERT(pIPtr-&gt;hasField("m_int32") == true, "m_id1 = true expected");
pIPtr-&gt;getField("m_int32", val);
wpiPtr-&gt;setField("m_int32", val + 1);
rptr-&gt;put(keyport, wpiPtr);  
PdxInstancePtr newPiPtr = dynCast&lt;PdxInstancePtr&gt;(rptr-&gt;get(keyport));  
ASSERT(newPiPtr-&gt;hasField("m_int32") == true, "m_int32 = true expected");
newPiPtr-&gt;getField("m_int32", newVal);  
ASSERT(val + 1 == newVal, "val + 1 == newVal expected");  
ASSERT((*pIPtr.ptr() == *newPiPtr.ptr()) == false, 
       "PdxInstance should not be equal");
</codeblock>
		<p>In addition to field access, <codeph>PdxInstance</codeph> also
			supports field modification using the
				<codeph>setField(fieldName)</codeph> method. The
				<codeph>setField</codeph> method has copy-on-write semantics. So
			for the modifications to be stored in the cache, the
				<codeph>PdxInstance</codeph> must be put into a region after
				<codeph>setField</codeph> has been called one or more times.
		</p>
	</conbody>
</concept>
