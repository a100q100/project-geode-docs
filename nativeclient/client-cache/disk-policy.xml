<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "http://docs.oasis-open.org/dita/v1.1/OS/dtd/concept.dtd">
<concept
	id="disk-policy">
	<title>DiskPolicy</title>
	<conbody>
		<section
			id="section_F3A921FC67B44DD795BD9B5C180FCBB1">
			<p>If the <codeph>lru-entries-limit</codeph> attribute is greater than zero, the
				optional <codeph>disk-policy</codeph> attribute determines how over-limit LRU
				entries are handled. LRU entries over the limit are either destroyed by default
					(<codeph>disk-policy</codeph> is none ) or written to disk
					(<codeph>overflows</codeph>). </p>
				<note>
					<p>If <codeph>LruEntriesLimit</codeph> is <codeph>0</codeph>, or
						<codeph>CachingEnabled</codeph> is <codeph>false</codeph>, do not set the
						<codeph>disk-policy</codeph> attribute. An
						<codeph>IllegalStateException</codeph> is thrown if the attribute is set.
					</p>
				</note>
			<p>This declaration causes LRU to overflow to disk: </p>
			<codeblock>&lt;region-attributes lru-entries-limit="20000"
    disk-policy="overflows"&gt;
  &lt;persistence-manager ... /&gt;
&lt;/region-attributes&gt;</codeblock>
			<p>Overflow requires a persistence manager for cache-to-disk and disk-to-cache
				operations. See <xref
					scope="local"
					href="persistence-manager.xml#persistence-manager"
					type="concept"
					format="dita">PersistenceManager</xref>. </p>
		</section>
		<section
			id="section_FE325E59644149ACA43DA2ABB4CF0F7A">
			<title>Overflowing Data to Disk</title>
			<p>Region data can be stored to disk using the overflow process to satisfy region
				capacity restrictions without completely destroying the local cache data. The
				storage mechanism uses disk files to hold region entry data. When an entry is
				overflowed, its value is written to disk but its key and entry object remain in the
				cache. This also uses the region attribute <xref
					scope="local"
					href="disk-policy.xml#disk-policy"
					type="concept"
					format="dita">DiskPolicy</xref>. </p>
			<p>Overflow allows you to keep the region within a user-specified size in memory by
				relegating the values of least recently used (LRU) entries to disk. Overflow
				essentially uses disk as a swap space for entry values. When the region size reaches
				the specified threshold, entry values are moved from memory to disk, as shown in the
				following figure. If an entry is requested whose value is only on disk, the value is
				copied back into memory, possibly causing the value of a different LRU entry to be
				overflowed to disk. </p>
			<fig
				id="fig_67963EC3BDD64272BBDAD9517E1D78A0">
				<title>Data Flow Between Overflow Region and Disk Files</title>
				<image
					placement="break"
					href="../common/images/client-cache-data-flow.gif"
					id="image_687021ECD97A40FB843DBDE59C555384">
					<alt>Data Flow Between Overflow Region and Disk Files </alt>
				</image>
			</fig>
			<p>In this figure the value of the LRU entry X has been moved to disk to recover space
				in memory. The key for the entry remains in memory. From the distributed system
				perspective, the value on disk is as much a part of the region as the data in
				memory. A <codeph>get</codeph> performed on region B looks first in memory and then
				on disk as part of the local cache search. </p>
		</section>
	</conbody>
</concept>
