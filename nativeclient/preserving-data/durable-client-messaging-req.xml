<?xml version="1.0"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept
	id="concept_0678F06652E741EE89DD36232BF875FD">
	<title>Durable Client Messaging Requirements</title>
	<shortdesc>The messaging queues used for durable messaging are the same regular messaging queues
		used for basic server-to-client messaging, with additional requirements. </shortdesc>
	<conbody>
		<p>See <xref href="../../developing/events/implementing_durable_client_server_messaging.xml"/> for
			requirements, options, and functionality of messaging queues. If you are using highly
			available servers, see <xref
				href="high-availability-client-server.xml#concept_F7A143F51EEA46B28AC612DEB7849D99"
				type="concept" format="dita" scope="local"
				><?xm-replace_text High Availability for Client-Server Communication?></xref>for
			additional requirements. </p>
		<p>For durable client messaging, you also need the following: </p>
		<ul
			id="ul_8BFAF7B26EDF43FBB316FF501498BD69">
			<li
				id="li_350A2BB07AB340E88A3943AEDD092B49"><b>Durable clients</b>. If the client is
				durable, the server continues to maintain the client queues when the client
				disconnects. 
					<note>
						<p>Redundancy management is handled by the client, so when the client is
						disconnected from the server the redundancy of client events is not
						maintained. Even if the servers fail one at a time, so that running clients
						have time to fail over and pick new secondary servers, an offline durable
						client cannot fail over. As a result, the client loses its queued messages.
						</p>
					</note>
			</li>
			<li
				id="li_956D1F9F1707493C829ED4A124CE9EBA"><b>Durable interest registration</b>. A
				durable clientâ€™s interest registrations specify whether its interest in a key is
				durable. If it is, the servers continue queuing messages for that key while the
				client is disconnected. </li>
			<li><b>Reconnection conditions.</b> You can program the durable client to detect whether
				the previously registered subscription queue is available upon reconnection and
				determine an approximate count of pending events in the queue. Based on the results,
				you can then decide whether to receive the remaining events
					(<codeph>Cache.readyForEvents</codeph>) or close the cache if the number is too
				large.</li>
			<li
				id="li_B91D602EC2A749EB9E2CBAEA60CA0C88"><b>Cache ready message</b>. When it is
				ready to receive the stored messages, a durable client must call
					<codeph>Cache.readyForEvents</codeph> to send a cache ready message to the
				server. </li>
			<li
				id="li_FF689F6AA6A94060823C6A9A7E979B0F"><b>Disconnect keepalive specification</b>.
				When a durable client disconnects normally it must tell the server whether to
				maintain the message queue or delete it. </li>
			<li
				id="li_368E3F1E1DF846E4AA8929B9DC7CBDDC"><b>Durable client callback method</b>. If
				you use cache listeners on the durable clients, you have the option to implement the
					<codeph>afterRegionLive</codeph> callback method. This callback is invoked after
				the durable client connects to its servers, when it has received all of its stored
				messages and replayed the events. </li>
		</ul>
	</conbody>
</concept>
