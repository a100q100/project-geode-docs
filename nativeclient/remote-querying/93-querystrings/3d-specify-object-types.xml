<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept
	id="security">
	<title
		id="title_9717E51087B346988389138843E158C4">Specifying the Object Types of FROM Clause
		Collections</title>
	<conbody>
		<p>To resolve implicit attribute names, the query engine must be able to associate each
			attribute or method name to a single iterator expression in the <codeph>FROM</codeph>
			clause. </p>
		<p>Depending on the complexity of the query, the engine may be able to discover the proper
			associations on its own, but providing the specifications described here increases the
			chances for success. </p>
		<p>The server region being queried should contain only homogeneous objects of the same type. See <xref
				href="../91-quickintro/3-quickintro-requirements.xml#security/section_407A315F22014CD8A0BC622454789888"
				type="section"
				format="dita"
				scope="local">Setting Object Type Constraints</xref> for more information. </p>
		<p> The object type information must be available when the query is created. To provide the
			appropriate information to the query engine, specify the type for each of your
				<codeph>FROM</codeph> clause collection objects by importing the object's class
			before running the query and typing the object inside the query. For the example region,
			this query is valid (all of the examples in this section assume that this
				<codeph>IMPORT</codeph> statement is provided): </p>
		<p>
			<b>Query Using IMPORT and TYPE for Object Typing</b></p>
			<codeblock>IMPORT javaobject.Position;
SELECT DISTINCT mktValue
FROM /portfolios, positions.values TYPE Position
WHERE mktValue &gt; 25.00</codeblock>
		<p>This entire query string must be passed to the query engine, including the IMPORT
			statement. Import the objectâ€™s class before running the query and typecast the object
			inside the query. For the example region, both of these queries are valid: </p>
		<p>
			<b>Query Using IMPORT and Typecasting for Object Typing</b></p>
			<codeblock>IMPORT javaobject.Position;
SELECT DISTINCT value.mktValue
  FROM /portfolios, (map&lt;string,Position&gt;)positions
  WHERE value.mktValue &gt; 25.00
IMPORT cacheRunner.Position;
SELECT DISTINCT mktValue
  FROM /portfolios, (collection&lt;Position&gt;)positions.values
  WHERE mktValue &gt; 25.00</codeblock>
		<p>This entire query string must be passed to the query engine, including the
				<codeph>IMPORT</codeph> statement. Use named iterators in the <codeph>FROM</codeph>
			clause and explicitly prefix the path expression with iterator names. </p>
		<p>
			<b>Query Using Named Iterators for Object Typing</b></p>
			<codeblock>SELECT DISTINCT posnVal

FROM /portfolios pflo, pflo.positions.values posnVal

WHERE posnVal.mktValue &gt;= 25.00</codeblock>
		<p>The <codeph>IMPORT</codeph> statements in these examples assume that the
				<codeph>classes</codeph> directory of the examples is in the
				<codeph>CLASSPATH</codeph>. This is required so the cache server can process
				<codeph>IMPORT</codeph> statements. The class's package name cannot be used in the
				<codeph>FROM</codeph> clause. The package name must be specified in an
				<codeph>IMPORT</codeph> statement. </p>
		<p> There is one exception to these typing guidelines. If one <codeph>FROM</codeph>
			expression lacks explicit typing, the query engine associates all unresolved attributes
			with that expression and creates the query. An exception is thrown if any of these
			attributes are not found at execution time. </p>
	</conbody>
</concept>
