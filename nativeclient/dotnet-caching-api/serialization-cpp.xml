<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN"
"concept.dtd">
<concept id="serialization-cpp">
  <title>C++ Example</title>

  <conbody>
    <p><fig>
        <title>Implementing an Embedded Object (C++)</title>

        <codeblock>class User
: public Serializable
{
 private:
  std::string name;
  int32_t userId;
  ExampleObject *eo;
 public:
 User( std::string name, int32_t userId )
   : name( name ),userId( userId )
  {
    eo = new ExampleObject(this-&gt;userId);
  }
 
  ~User() {
    if (eo != NULL) delete eo;
    eo = NULL;
  }
 
  User ()
    {
      name = "";
      userId = 0;
      eo = new ExampleObject(userId);
    }
 
  User( const char *strfmt, char delimeter )
    {
      std::string userId_str;
      std::string sValue(strfmt);
      std::string::size_type pos1 = sValue.find_first_of(delimeter);
      std::string::size_type pos2;
      if (pos1 == std::string::npos) {
        userId_str = sValue;
        name = sValue;
      }
      else {
        userId_str = sValue.substr(0, pos1);
        pos2 = sValue.find(delimeter, pos1+1);
        int len;
        if (pos2==std::string::npos) {
          len = sValue.length()-pos1;
        }
        else {
          len = pos2-pos1;
        }
        name = sValue.substr(pos1+1, len);
      }
      userId = (int32_t)atoi(userId_str.c_str());
      eo = new ExampleObject(userId_str);
    }
 
  CacheableStringPtr toString() const
  {
    CacheableStringPtr eo_str = eo-&gt;toString();
    char userId_str[128];
    sprintf(userId_str,"User: %d", userId);
    std::string sValue = std::string(userId_str) + "," + name + "\n";
    sValue += std::string(eo_str-&gt;asChar());
    return CacheableString::create( sValue.c_str() );
  }
 
  int32_t getUserId( )
  {
    return userId;
  }
 
  std::string getName( )
    {
      return name;
    }
 
  ExampleObject *getEO()
  {
    return eo;
  }
 
  void setEO(ExampleObject *eObject)
  {
    eo = eObject;
  }
 
  // Add the following for the Serializable interface
  // Our TypeFactoryMethod
 
  static Serializable* createInstance( )
  {
    return new User(std::string("gester"), 123);
  }
 
  int32_t classId( ) const
  {
    return 0x2d; // 45
  }
 
  void toData( DataOutput&amp; output ) const
  {
    output.writeASCII( name.c_str(), name.size() );
    output.writeInt( userId );
    eo-&gt;toData(output);
  }
 
  uint32_t objectSize( ) const
  {
    return ( sizeof(char) * ( name.size() + 1 ) ) +
      sizeof(User) + eo-&gt;objectSize();
  }
 
  Serializable* fromData( DataInput&amp; input )
  {
    char *readbuf;
    input.readASCII( &amp;readbuf );
    name = std::string(readbuf);
    input.freeUTFMemory( readbuf );
    input.readInt( &amp;userId );
    eo-&gt;fromData(input);
    return this;
  }
};</codeblock>
      </fig><fig>
        <title>Implementing Complex Data Types (C++)</title>

        <codeblock>class ExampleObject
: public Serializable
{
 private:
  double double_field;
  float float_field;
  long long_field;
  int int_field;
  short short_field;
  std::string string_field;
  std::vector&lt;std::string&gt; string_vector;
 public:
  ExampleObject() {
    double_field = 0.0;
    float_field = 0.0;
    long_field = 0;
    int_field = 0;
    short_field = 0;
    string_field = "";
    string_vector.clear();
  }
  ~ExampleObject() {
  }
  ExampleObject(int id) {
    char buf[64];
    sprintf(buf, "%d", id);
    std::string sValue(buf);
    int_field = id;
    long_field = int_field;
    short_field = int_field;
    double_field = (double)int_field;
    float_field = (float)int_field;
    string_field = sValue;
    string_vector.clear();
    for (int i=0; i&lt;3; i++) {
      string_vector.push_back(sValue);
    }
  }
  ExampleObject(std::string sValue) {
    int_field = atoi(sValue.c_str());
    long_field = int_field;
    short_field = int_field;
    double_field = (double)int_field;
    float_field = (float)int_field;
    string_field = sValue;
    string_vector.clear();
    for (int i=0; i&lt;3; i++) {
      string_vector.push_back(sValue);
    }
  }
  CacheableStringPtr toString() const {
    char buf[1024];
    std::string sValue = "ExampleObject: ";
    sprintf(buf,"%f(double),%f(double),%ld(long),%d(int),%d(short),", double_field,float_field,long_field,int_field,short_field);
    sValue += std::string(buf) + string_field + "(string),";
    if (string_vector.size() &gt;0) {
      sValue += "[";
      for (unsigned int i=0; i&lt;string_vector.size(); i++) {
        sValue += string_vector[i];
        if (i != string_vector.size()-1) {
          sValue += ",";
        }
      }
      sValue += "](string vector)";
    }
    return CacheableString::create( sValue.c_str() );
  }
  double getDouble_field() {
    return double_field;
  }
  float getFloat_field() {
    return float_field;
  }
  long getLong_field() {
    return long_field;
  }
  int getInt_field() {
    return int_field;
  }
  short getShort_field() {
    return short_field;
  }
  std::string &amp; getString_field() {
    return string_field;
  }
  std::vector&lt;std::string&gt; &amp; getString_vector( ) {
    return string_vector;
  }
 
  // Add the following for the Serializable interface
  // Our TypeFactoryMethod
 
  static Serializable* createInstance( ) {
    return new ExampleObject();
  }
  int32_t classId( ) const
  {
    return 0x2e; // 46
  }
  bool operator == ( const Serializable&amp; other ) const {
    const ExampleObject&amp; otherEO = static_cast&lt;const ExampleObject&amp;&gt;( other );
    return ( 0 == strcmp( otherEO.toString()-&gt;asChar(), toString()-&gt;asChar() ) );
  }
  uint32_t hashcode( ) const {
    return int_field;
  }
 
  uint32_t objectSize( ) const
  {
    uint32_t objectSize = sizeof(ExampleObject);
    objectSize += sizeof(char) * ( string_field.size() + 1 );
    size_t itemCount = string_vector.size();
    for( size_t idx = 0; idx &lt; itemCount; idx++ ) {
      // copy each string to the serialization buffer, including the null
      // terminating character at the end of the string.
      objectSize += sizeof(char) * ( string_vector[idx].size() + 1 );
    }
    return objectSize;
  }
 
  void toData( DataOutput&amp; output ) const {
    output.writeDouble( double_field );
    output.writeFloat( float_field );
    output.writeInt( (int64_t)long_field );
    output.writeInt( (int32_t)int_field );
    output.writeInt( (int16_t)short_field );
    output.writeASCII( string_field.c_str(), string_field.size());
    size_t itemCount = string_vector.size();
    output.writeInt( (int32_t) itemCount );
    for( size_t idx = 0; idx &lt; itemCount; idx++ ) {
      // copy each string to the serialization buffer, including the null
      // terminating character at the end of the string.
      output.writeASCII( string_vector[idx].c_str(), string_vector[idx].size() );
    }
  }
 
  Serializable* fromData( DataInput&amp; input )
  {
    char *readbuf;
    input.readDouble( &amp;double_field );
    input.readFloat( &amp;float_field );
    input.readInt( (int64_t *)(void *)&amp;long_field );
    input.readInt( (int32_t *)(void *)&amp;int_field );
    input.readInt( (int16_t *)(void *)&amp;short_field );
 
    int32_t itemCount = 0;
    input.readASCII( &amp;readbuf );
    string_field = std::string(readbuf);
    input.freeUTFMemory( readbuf );
 
    string_vector.clear();
    input.readInt( (int32_t*) &amp;itemCount );
    for( int32_t idx = 0; idx &lt; itemCount; idx++ ) {
      // read from serialization buffer into a character array
      input.readASCII( &amp;readbuf );
      // and store in the history list of strings.
      string_vector.push_back( readbuf );
      input.freeUTFMemory( readbuf );
    }
    return this;
  }
};
typedef SharedPtr&lt;ExampleObject&gt; ExampleObjectPtr;</codeblock>
      </fig></p>
  </conbody>
</concept>
