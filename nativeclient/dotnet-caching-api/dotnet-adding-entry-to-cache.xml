<?xml version="1.0"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept
	id="concept_51D1C2475B394B10868CE6ED8DC5E542">
	<title>Adding an Entry to the Cache</title>
	<shortdesc>You populate a native client region with cache entries by using the generic
			<codeph>IDictionary</codeph> API or by using the .NET <codeph>Region.Put</codeph> or the
			<codeph>Region.Create</codeph> API functions. </shortdesc>
	<conbody>
		<p>The <codeph>Put</codeph> function places a new value into a region entry with the
			specified key, while the <codeph>Create</codeph> function creates a new entry in the
			region. The <codeph>Put</codeph> and <codeph>Create</codeph> functions provide a
			user-defined parameter object to any cache writer invoked in the process. </p>
		<p>If a value for the entry key already exists in the cache when you add an entry, <keyword
				keyref="product_name"/> overwrites the previously cached value. New values in the
			cache are propagated to the connected cache server. </p>
		<p>The .NET Generics provide type safety, so you cannot change your entry key and value
			types once you have begun to populate the region. If you need to use different types for
			the same region, store them all inside objects in the region. </p>
		<example
			id="example_1B5B9D68DEC9480588E18A405D28BBAD">
			<title>Using the API to Put Values Into the Cache</title>
			<p>In this example, the program puts entries into the cache with string values.</p>
				<codeblock>region1["Key1"] = "Value1";
region1["Key2"] = "Value2";
 
region2["KeyA"] = 123;
region2["KeyB"] = 100;
region3.Put(111, "Value1", null);
region3.Put(222, "Value2", null);</codeblock>
		</example>
		<section
			id="section_8DAEA246DA464BD1B9654827A84A93BF">
			<title>Batch Operationsâ€”Using PutAll to Add Multiple Entries</title> You can batch up
			multiple key/value pairs into a hashmap and put them into the cache with a single
			operation using the .NET <codeph>Region.PutAll</codeph> API function. Each entry is
			processed for interest registration on the server, so each entry requires its own unique
			event ID. Updates and creates can be mixed in a <codeph>PutAll</codeph> operation, so
			those events need to be addressed on the cache server for appropriate cache listener
			invocation on distributed system members. Map entries retain their original order when
			they are processed at the server. </section>
	</conbody>
</concept>
