<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="performance">
  <title id="title_1A5E3AB6BBA748C0AFAD8E42695FC006">Performance Considerations and Limitations</title>

  <conbody id="conbody_AF49CC0DC9874A14B32DC72620BB3639">
    <p id="p_EC584159A07540E59BF44CDAC081C6F1">The main purpose of delta propagation is to reduce the overhead of
    sending large amounts of data over the network.</p>

    <p id="p_EE0EC337E9ED42DA92D15EE5A5DCF26E">Generally, the larger your objects and the smaller the deltas, the
    greater the benefits of using delta propagation. Partitioned regions
    generally benefit more with higher redundancy levels. </p>

    <p id="p_DFB8DD1DA1134BF79EA6FF292594C053">Delta propagation does not show any significant benefits in some
    application scenarios. On occasion it results in degradation. The main
    areas of consideration are: </p>

    <ul id="ul_DE0E31A5CBE7421B82875D60EB780548">
      <li id="li_79075597DF4E42D49F186312358C41FC">Added costs of deserializing your objects to apply deltas. Applying
      a delta requires the entry value to be deserialized. Once this is done,
      the object is stored back in the cache in deserialized form. This aspect
      of delta propagation only negatively impacts your system if your objects
      are not already being deserialized for other reasons, such as for
      indexing and querying or for listener operations. Once stored in
      deserialized form, there are reserialization costs for operations that
      send the object outside of the member, like values sent in response to
      netSearch or client requests, and storage to disk. The more operations
      that require reserialization, the higher the overhead of deserializing
      the object. </li>

      <li id="li_9D952F5FF78546CAB0EE5C7F80AF789D">Cloning. Using cloning can affect performance. Not using cloning is
      risky, however, as you are modifying cached values in place. Make sure
      you synchronize your entry access to keep your cache from becoming
      inconsistent. </li>

      <li id="li_D30E8BD74F2F4E5D86099BB2907DC545">Problems applying the delta that cause the system to go back to the
      originator for the full entry value. When this happens, the overall
      operation costs more than sending the full entry value in the first
      place. This can be additionally aggravated if your delta is sent to a
      number of recipients, all or most of them request a full value, and the
      full value send requires the object to be serialized. </li>

      <li id="li_B5CBBE2CAC814433843351C900604783">Disk I/O costs associated with overflow regions. If you use eviction
      with overflow to disk, on-disk values must be brought into memory in
      order to apply the delta. This is much more costly than removing the
      reference to the disk copy, as you would do with a full value
      distribution into the cache.</li>
    </ul>
  </conbody>
</concept>
