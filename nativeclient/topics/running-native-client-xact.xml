<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="running-native-client-xact">
  <title id="title_9717E51087B346988389138843E158C4">Running a Native Client Transaction</title>

  <conbody id="conbody_D74C4342289846619E028149A8920946">
    <p id="p_73C402816B974E4B9D904000F996DD2E">Before you begin, have your clients and servers configured and have
    your server regions defined for your transactions and your client regions
    defined. For information on server and server region configuration, see
    the <i>GemFire Userâ€™s Guide</i>.</p>

    <ol id="ol_C07B2C97ED4942198D2C69CC8619B0AA">
      <li id="li_F6109E270B8D4AA4B0D51DD852FF3FBC"><p id="p_215060DA14754312AFE5B75CE8A1E74B">Program to retrieve the GemFire cache transaction manager.
      </p><fig id="fig_F7BBA12DA07343A79896E40D2187B0CE">
          <title>C++ example:</title>

          <codeblock id="codeblock_E8BA26FFF5AB4038AFB9AC1FA64B4694">CacheTransactionManagerPtr txManager = 
cache-&gt;getCacheTransactionManager(); </codeblock>
        </fig><fig id="fig_C0F0CDECB7DA459D9295BACD4A0EEEC8">
          <title id="title_22E2BBF6349E492EAD8E6A31C73972D2">C# .NET example:</title>

          <codeblock id="codeblock_560E9FB11530473199E5E48D6E264144">CacheTransactionManager txManager =
cache.CacheTransactionManager;</codeblock>
        </fig></li>

      <li id="li_42CD155D5353451F862CD23907408B4B"><p id="p_557EE2BB3D484A8C955C4C3BD6B1D71E"> Program to run your transaction. </p><fig id="fig_F942182EE6254E2AA349EC17F598A1E7">
          <title>C++ example:</title>

          <codeblock id="codeblock_86236E9ED77642F887E8F1CB0ADCF6E1">TransactionIdPtr tid;
txManager-&gt;begin();
// ..do work
tid = txManager-&gt;suspend();
// following code can be run from another
// thread that has access to tid
try {
  txManager-&gt;resume(tid);
  // ..do work
  tid = txManager-&gt;commit();
  catch (const CommitConflictException&amp; e)
  }</codeblock>
        </fig><fig id="fig_19F545C510174583BF58E66313913FF0">
          <title id="title_9E008FC644DA47259DEF09E1A81102BE">C# .NET example:</title>

          <codeblock id="codeblock_BFE7485AF958458D9FFE5372E569577B">TransactionId tid;
txManager.Begin();
// ..do work
tid = txManager.Suspend();
// following code can be run from another
// thread that has access to tid
try {
  txManager.Resume(tid);
  // ..do work
  txManager.Commit();
  }
catch (CommitConflictException e)</codeblock>
        </fig><ul id="ul_1BAFE2A7CBED4F7686ED2175144F7C9A">
          <li id="li_D30468BC0470407BAA55BB2D63CDA508">Start each transaction with a <codeph>begin</codeph>
          operation.</li>

          <li id="li_2D6AFB6BED504514B890CDF5203A2D8D">If your transaction runs on server regions that are a mix of
          partitioned and replicated regions, perform your first transaction
          operation on a partitioned region. This sets the server data host
          for the entire transaction. If you are using PR single-hop,
          single-hop will be applied as usual to this first operation.</li>

          <li>Run the GemFire operations and other operations that you want
          included in the transaction.</li>

          <li id="li_C37077FF0D8B48F5AB902632FE31792C"><p id="p_0CF2F25F1E804420A838EFF9F37802F8">End each transaction with a <codeph>commit</codeph> or a
          <codeph>rollback</codeph>.</p><note id="note_56215AA771CC40099629892A6DD20FF8">Do not leave any transaction in
          an uncommitted and unrolled back state unless you are have suspended
          the transaction. Transactions that have not been explicitly
          suspended do not time out, so will remain in the system for the life
          of your application.</note></li>
        </ul></li>

      <li id="li_A0DDFA0E9F5D493EBA169F6F9ED29181">Review all of your client code for compatibility with transactions.
      When you commit a transaction, while the commit is taking place, the
      changes are visible in the cache. This is also known as in transition
      commits. This provides better performance than locking everything to do
      the transaction updates, but it means that another process accessing
      data used in the transaction might get some data in the pre-transaction
      state and some in the post-transaction state. For example say key 1 and
      2 are written to in a transaction so both of their values change from A
      to B. In another thread, it is possible to read key 1 with value B and
      key 2 with value A, while the transaction is being committed. This can
      happen because of how GemFire performs reads. This choice sacrifices
      atomic visibility in favor of performance. Reads don't block writes.
      Writes don't block reads.</li>
    </ol>

    <p id="p_AE1CE53BB4EF42D18F275B6EEE47957D">Because the client cache waits during transaction execution, and client
    regions are not distributed, the only activities that interact with a
    client transaction are those that happen on the server. </p>
  </conbody>
</concept>
