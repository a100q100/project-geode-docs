<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept
	id="performance">
	<title
		id="title_1A5E3AB6BBA748C0AFAD8E42695FC006">Exceptions and Limitations </title>
	<conbody
		id="conbody_AF49CC0DC9874A14B32DC72620BB3639">
		<p
			id="p_EC584159A07540E59BF44CDAC081C6F1">In some application scenarios, delta propagation
			does not show any significant performance benefits. On occasion it results in
			degradation. There are other limitations and exceptions related to delta propagation. </p>
		<section
			id="section_26DE70BF948F4B55A36A7B91C9AE2751">
			<title>Errors in Delta Propagation</title>
			<p
				id="p_26563964E8BA4EBF93F4504FA752A25D">
				
Errors in delta propagation fall into two categories based on how
they are handled: </p>
			<ul
					id="ol_66BCC3C71EA34FCFA36EC3A6BD5FB613">
					<li
						id="li_A8D39303D7B44D9CBDA2EC4077E62EA1">
						<p
							id="p_A63F10EC6E3F4EB88E3D53615B9E4DC5"><b>Problems applying the delta
								that can be remedied if the originating member sends the full value
								in place of the delta.</b> Your put operation does not see errors or
							exceptions related to the failed delta propagation. The system
							automatically does a full value distribution to the receiver where the
							problem occurs. This type of error includes: </p>
						<ul
							id="ul_01AA34A2F1A24E64989D2ADCCFB432D3">
							<li
								id="li_55680F6D311D47E98B393784FEE5C487">Unavailable entry value in
								the receiving cache, either because the entry is missing or its
								value is null. In both cases, there is nothing to apply the delta to
								and the full value must be sent. This is most likely to occur if you
								destroy or invalidate your entries locally, either through
								application calls or through configured actions like eviction or
								entry expiration. </li>
							<li id="li_D358C947A8A44B208193DE425EFC7C00"><codeph>InvalidDeltaException</codeph> thrown by
								<codeph>fromDelta</codeph> method, programmed by you. This exception
							enables you to avoid applying deltas that would violate data consistency
							checks or other application requirements. Throwing this exception causes
								<keyword keyref="product_name"/> to send the full value. </li>
							<li
								id="li_51DE3F7274364B02AD8518B896863048">Any error applying the
								delta in a client in server-to-client propagation. The client
								retrieves the full value from the server. </li>
						</ul>
					</li>
					<li
						id="li_B230F1D8100D4E1EAD0322F80D6372DD"><b>Problems creating or
							distributing the delta that cannot be fixed by distributing the full
							value.</b> These problems are caused by errors or exceptions in
							<codeph>hasDelta</codeph> or <codeph>toDelta</codeph>. In these cases,
						your <codeph>put</codeph> operation fails with an exception. </li>
				</ul>
		</section>
		<section
			id="section_39CE903E2C0C412E891C420C59AB4588">
			<title>Performance Limitations</title>
			<p
				id="p_DFB8DD1DA1134BF79EA6FF292594C053"> Consider the following situations in which
				delta propagation adversely affects performance: </p>
				<ul
					id="ul_DE0E31A5CBE7421B82875D60EB780548">
					<li
						id="li_79075597DF4E42D49F186312358C41FC"><b>Added costs of deserializing
							your objects to apply deltas</b>. Applying a delta requires the entry
						value to be deserialized. Once this is done, the object is stored back in
						the cache in deserialized form. This aspect of delta propagation only
						negatively impacts your system if your objects are not already being
						deserialized for other reasons, such as for indexing and querying or for
						listener operations. Once stored in deserialized form, there are
						reserialization costs for operations that send the object outside of the
						member, like values sent in response to netSearch or client requests, and
						storage to disk. The more operations that require reserialization, the
						higher the overhead of deserializing the object. </li>
					<li
						id="li_9D952F5FF78546CAB0EE5C7F80AF789D"><b>Cloning</b>. Cloning can affect
						performance. Not using cloning is risky, however, as you are modifying
						cached values in place. Make sure you synchronize your entry access to keep
						your cache from becoming inconsistent. </li>
					<li
						id="li_D30E8BD74F2F4E5D86099BB2907DC545"><b>Problems applying the delta that
							cause the system to go back to the originator for the full entry
							value</b>. In this scenario, the overall operation costs more than
						sending the full entry value in the first place. The problem can be
						exacerbated if your delta is sent to a number of recipients, all or most of
						them request a full value, and the full value send requires the object to be
						serialized. </li>
					<li
						id="li_B5CBBE2CAC814433843351C900604783"><b>Disk I/O costs associated with
							overflow regions</b>. If you use eviction with overflow to disk, on-disk
						values must be brought into memory in order to apply the delta. This is much
						more costly than removing the reference to the disk copy, as you would do
						with a full value distribution into the cache. </li>
				</ul>
		</section>
		<section
			id="section_F7BC60C9E89B44BBA3D06995D52574AC">
			<title>Configurations That Require Full Values </title>
			<p id="p_2C15926DEB9D4DE591E67F305555B416"><keyword keyref="product_name"/> clients can always
				send deltas to the servers, and servers can usually sent deltas to clients. The
				following configurations require the servers to send full values to the clients,
				instead of deltas: </p>
				<ul
					id="ul_850245D5314246B78146B1C7C4A4027F">
					<li
						id="li_3FD1B9731C584731A705A8C72402B32E">When the client's
							<codeph>gemfire.properties</codeph> setting
							<codeph>conflate-events</codeph> is set to <codeph>true</codeph>, the
						servers send full values for all regions. </li>
					<li
						id="li_C8F089442F274018932BAD332F1D1E39">When the server region attribute
							<codeph>enable-subscription-conflation</codeph> is set to
							<codeph>true</codeph> and the client <codeph>gemfire.properties</codeph>
						setting <codeph>conflate-events</codeph> is set to <codeph>server</codeph>,
						the servers send full values for the region. </li>
					<li
						id="li_A73EA0D60B5D408F9ED5886F3F659547">Servers send full values to client
						regions that are configured to not cache data—with the <codeph>PROXY
							RegionShortcut</codeph> in their region attributes
							<codeph>refid</codeph>. </li>
				</ul>
			<p
				id="p_88F6DF51DE774C628713EA34482C7A81">To use the delta propagation feature, all
				updates on a key in a region must have value types that implement the
					<codeph>Delta</codeph> interface. You cannot mix object types for an entry key
				where some of the types implement delta and some do not. This is because, when a
				type implementing the delta interface is received for an update, the existing value
				for the key is cast to a <codeph>Delta</codeph> type to apply the received delta.
			</p>
		</section>
		<section
			id="section_2767204E1914425BB8160E4347615B71">
			<title
				id="title_40FAAAD982ED4B5F9CAFFFF309F29D0C">General Limitations</title>
			<p
				id="p_8475B0BC9C7C4ED48E9972C66324D716">Sometimes <codeph>fromDelta</codeph> cannot
				be invoked because there is no object to apply the delta to in the receiving cache.
				When this happens, the system sends the full value. There are two possible
				scenarios: </p>
				<ul
					id="ul_2FEC933237774BBFAD49893DA5ACDE69">
					<li
						id="li_9C8566BFAB9147A6A7E23F2EEA4689FD">If the system can determine
						beforehand that the receiver does not have a local copy, it sends the
						initial message with the full value. This is possible when regions are
						configured with no local data storage, as when you are using them to provide
						data update information to listeners. </li>
					<li
						id="li_6B08D831F1574F84B8789144DCE7FDBB">In less obvious cases, as when an
						entry has been locally deleted, first the delta is sent, then the receiver
						requests a full value and that is sent. Whenever the full value is received,
						any further distributions to the receiver’s peers or clients uses the full
						value. </li>
				</ul>
			<p id="p_C024260C1CD8404184E0C4C37C1C693D"><keyword keyref="product_name"/> does not propagate
				deltas for:</p>
				<ul
					id="ul_38DDB19E4F904EBDB8D27E4A25BFF220">
					<li
						id="li_582CF574DABC4F7DA6822FAB03A72574">Transactional commit on the server </li>
					<li
						id="li_DFF1E0D63C544263B9F2EB0C8DA707AD">The <codeph>putAll</codeph>
						operation </li>
				</ul>
		</section>
	</conbody>
</concept>
